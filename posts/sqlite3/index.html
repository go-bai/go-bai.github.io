<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  rollback日志模式下的五种锁状态介绍
  #


UNLOCKED

没锁状态


SHARED

获取SHARED锁才能执行读操作，一个数据库可同时存在多个SHARED锁


RESERVED

获取RESERVED锁才能在未来写数据库，一个数据库同一时间只能存在一个RESERVED锁
有RESERVED锁时说明还没开始写，所以有RESERVED锁时可以获取新的SHARED锁


PENDING

有PENDING锁意味着要开始写了，但是此时有其他连接拥有SHARED锁在读数据，此时写操作只能等待所有SHARED释放。
PENDING阻塞其他连接获取新的SHARED锁，当SHARED锁释放完时转为EXCLUSIVE锁开始写操作。


EXCLUSIVE

同一时间只能存在一个EXCLUSIVE锁，并且有EXCLUSIVE锁存在时不允许其他任何锁类型存在。



所以总结一下就是读读可并发，读写不可并发，写写不可并发。

  优化篇
  #


  SQLITE_BUSY 问题
  #

看到上面这么多锁不能共存的情况应该会想到，冲突会很频繁，如 EXCLUSIVE 锁存在时不允许其他连接获取任何锁，当其他进程需要读写操作时就会获取锁失败，立即报 SQLITE_BUSY 错误。
设置 busy_timeout 就不会立即返回 SQLITE_BUSY，会定时retry失败的操作，如果在设置的 busy_timeout 时间内还没执行成功，依然会返回 SQLITE_BUSY。
使用不同sqlite驱动，设置 busy_timeout 的方式不同

modernc.org/sqlite database.db?_pragma=busy_timeout%3d50000
github.com/mattn/go-sqlite3 database.db?_busy_timeout=50000

Shared cache mode 支持 table level locks，暂时还没研究。

  针对写操作慢的问题
  #

解决方案：将多个写操作放入一个事务里执行。sqlite官方FAQ对其解释如下

(19) INSERT is really slow - I can only do few dozen INSERTs per second
Actually, SQLite will easily do 50,000 or more INSERT statements per second on an average desktop computer. But it will only do a few dozen transactions per second. Transaction speed is limited by the rotational speed of your disk drive. A transaction normally requires two complete rotations of the disk platter, which on a 7200RPM disk drive limits you to about 60 transactions per second.
Transaction speed is limited by disk drive speed because (by default) SQLite actually waits until the data really is safely stored on the disk surface before the transaction is complete. That way, if you suddenly lose power or if your OS crashes, your data is still safe. For details, read about atomic commit in SQLite..
By default, each INSERT statement is its own transaction. But if you surround multiple INSERT statements with BEGIN&mldr;COMMIT then all the inserts are grouped into a single transaction. The time needed to commit the transaction is amortized over all the enclosed insert statements and so the time per insert statement is greatly reduced.
Another option is to run PRAGMA synchronous=OFF. This command will cause SQLite to not wait on data to reach the disk surface, which will make write operations appear to be much faster. But if you lose power in the middle of a transaction, your database file might go corrupt."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="/posts/sqlite3/"><meta property="og:site_name" content="gobai's notes"><meta property="og:title" content="SQLite3"><meta property="og:description" content="rollback日志模式下的五种锁状态介绍 # UNLOCKED 没锁状态 SHARED 获取SHARED锁才能执行读操作，一个数据库可同时存在多个SHARED锁 RESERVED 获取RESERVED锁才能在未来写数据库，一个数据库同一时间只能存在一个RESERVED锁 有RESERVED锁时说明还没开始写，所以有RESERVED锁时可以获取新的SHARED锁 PENDING 有PENDING锁意味着要开始写了，但是此时有其他连接拥有SHARED锁在读数据，此时写操作只能等待所有SHARED释放。 PENDING阻塞其他连接获取新的SHARED锁，当SHARED锁释放完时转为EXCLUSIVE锁开始写操作。 EXCLUSIVE 同一时间只能存在一个EXCLUSIVE锁，并且有EXCLUSIVE锁存在时不允许其他任何锁类型存在。 所以总结一下就是读读可并发，读写不可并发，写写不可并发。
优化篇 # SQLITE_BUSY 问题 # 看到上面这么多锁不能共存的情况应该会想到，冲突会很频繁，如 EXCLUSIVE 锁存在时不允许其他连接获取任何锁，当其他进程需要读写操作时就会获取锁失败，立即报 SQLITE_BUSY 错误。
设置 busy_timeout 就不会立即返回 SQLITE_BUSY，会定时retry失败的操作，如果在设置的 busy_timeout 时间内还没执行成功，依然会返回 SQLITE_BUSY。
使用不同sqlite驱动，设置 busy_timeout 的方式不同
modernc.org/sqlite database.db?_pragma=busy_timeout%3d50000 github.com/mattn/go-sqlite3 database.db?_busy_timeout=50000 Shared cache mode 支持 table level locks，暂时还没研究。
针对写操作慢的问题 # 解决方案：将多个写操作放入一个事务里执行。sqlite官方FAQ对其解释如下
(19) INSERT is really slow - I can only do few dozen INSERTs per second Actually, SQLite will easily do 50,000 or more INSERT statements per second on an average desktop computer. But it will only do a few dozen transactions per second. Transaction speed is limited by the rotational speed of your disk drive. A transaction normally requires two complete rotations of the disk platter, which on a 7200RPM disk drive limits you to about 60 transactions per second. Transaction speed is limited by disk drive speed because (by default) SQLite actually waits until the data really is safely stored on the disk surface before the transaction is complete. That way, if you suddenly lose power or if your OS crashes, your data is still safe. For details, read about atomic commit in SQLite.. By default, each INSERT statement is its own transaction. But if you surround multiple INSERT statements with BEGIN…COMMIT then all the inserts are grouped into a single transaction. The time needed to commit the transaction is amortized over all the enclosed insert statements and so the time per insert statement is greatly reduced. Another option is to run PRAGMA synchronous=OFF. This command will cause SQLite to not wait on data to reach the disk surface, which will make write operations appear to be much faster. But if you lose power in the middle of a transaction, your database file might go corrupt."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-12-14T10:33:14+08:00"><meta property="article:modified_time" content="2025-03-11T11:08:31+08:00"><title>SQLite3 | gobai's notes</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=/posts/sqlite3/><link rel=stylesheet href=/book.min.434035e7885c7f5d12818bd9f111cf1a0925c6fb78382667381c3d5eda3fb4f1.css><script defer src=/fuse.min.js></script><script defer src=/en.search.min.04a6d3730b389ef48fa9b9962f04d3fd0c3ecb8eb3646dfbb55f14885a92f823.js></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><img src=/favicon.ico alt=Logo class=book-icon><span>gobai's notes</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><span>Golang</span><ul><li><input type=checkbox id=section-98d0efdb3baf67b2c791a7fd1bbf6ca1 class=toggle>
<label for=section-98d0efdb3baf67b2c791a7fd1bbf6ca1 class="flex justify-between"><a role=button>语言基础</a></label><ul><li><a href=/posts/go-memory-escape/>内存逃逸</a></li><li><a href=/posts/go-gc/>GC 垃圾回收</a></li><li><a href=/posts/go-make-and-new/>make 与 new 区别</a></li><li><a href=/posts/go-gmp/>GMP 模型</a></li></ul></li><li><input type=checkbox id=section-42d8c4148cb4c5a3e3d8addaded05197 class=toggle>
<label for=section-42d8c4148cb4c5a3e3d8addaded05197 class="flex justify-between"><a role=button>数据结构</a></label><ul><li><a href=/posts/go-interface/>interface</a></li><li><a href=/posts/go-chan/>channel</a></li></ul></li><li><input type=checkbox id=section-1ca588caf6263863db394d8b5e8e27c7 class=toggle>
<label for=section-1ca588caf6263863db394d8b5e8e27c7 class="flex justify-between"><a role=button>标准库</a></label><ul></ul></li><li><input type=checkbox id=section-241d5557475d85971162af97f6d52ccb class=toggle>
<label for=section-241d5557475d85971162af97f6d52ccb class="flex justify-between"><a role=button>三方库</a></label><ul><li><a href=/posts/sqlx-vs-xorm/>sqlx vs xorm</a></li></ul></li><li><input type=checkbox id=section-da889a16058efe316dfcb82b9003429e class=toggle>
<label for=section-da889a16058efe316dfcb82b9003429e class="flex justify-between"><a role=button>开发工具</a></label><ul><li><a href=/posts/go-delve/>Delve</a></li><li><a href=/posts/go-testing/>Testing</a></li></ul></li><li><input type=checkbox id=section-fcb09aa495225b08f1e972b051618bb6 class=toggle>
<label for=section-fcb09aa495225b08f1e972b051618bb6 class="flex justify-between"><a role=button>其他</a></label><ul><li><a href=/posts/solve-timezone-issue-in-go-application-in-container/>Go应用在容器中的时区</a></li><li><a href=/posts/go-app-reduce-size/>减小go程序编译后的体积</a></li></ul></li></ul></li><li><input type=checkbox id=section-f91fe725fab4dcbef0dd504359ff7b63 class=toggle>
<label for=section-f91fe725fab4dcbef0dd504359ff7b63 class="flex justify-between"><a role=button>Linux</a></label><ul><li><input type=checkbox id=section-176ad016ae09a9f0440dca17617492cb class=toggle>
<label for=section-176ad016ae09a9f0440dca17617492cb class="flex justify-between"><a role=button>Network</a></label><ul><li><a href=/posts/linux-iptables/>Linux iptables</a></li><li><a href=/posts/linux-bridge/>Linux Bridge</a></li><li><a href=/posts/wireless-to-wired-network/>无线转有线网络</a></li><li><a href=/posts/openwrt/>OpenWrt</a></li><li><a href=/posts/openwrt-v2/>OpenWrt v2</a></li><li><a href=/posts/dhclient/>dhclient 问题</a></li><li><a href=/posts/creating-a-bridged-network-with-netplan-on-ubuntu-22-04/>在 Ubuntu 22.04 使用 netplan 创建桥接网络</a></li></ul></li><li><input type=checkbox id=section-33e3a313f4903205bd4597f5f4045be9 class=toggle>
<label for=section-33e3a313f4903205bd4597f5f4045be9 class="flex justify-between"><a role=button>OS</a></label><ul><li><a href=/posts/netpoll/>Netpoll</a></li><li><a href=/posts/linux-boot-process-bios/>Linux 启动流程 (BIOS)</a></li><li><a href=/posts/multi-bootable-usb/>Multi-Bootable USB</a></li></ul></li><li><input type=checkbox id=section-3b63411eed8d0cecdd3250e70daaaace class=toggle>
<label for=section-3b63411eed8d0cecdd3250e70daaaace class="flex justify-between"><a role=button>Storage</a></label><ul><li><a href=/posts/procfs/>proc filesystem</a></li><li><a href=/posts/partitioning-disks/>Linux 磁盘分区</a></li><li><a href=/posts/inode/>Linux 文件系统之 inode</a></li><li><a href=/posts/delete-partition-and-expand-another/>删除分区并扩容另一个分区和根文件系统</a></li></ul></li><li><input type=checkbox id=section-244a9b038b0e0aa873cb558da61a18b1 class=toggle>
<label for=section-244a9b038b0e0aa873cb558da61a18b1 class="flex justify-between"><a role=button>其他</a></label><ul><li><a href=/posts/filebrowser/>Filebrowser 部署</a></li><li><a href=/posts/rclone/>Rclone 使用笔记</a></li><li><a href=/posts/shell-script/>Shell Script</a></li><li><a href=/posts/ubuntu-config/>Ubuntu Config</a></li><li><a href=/posts/systemd-journal/>About Systemd</a></li></ul></li></ul></li><li><input type=checkbox id=section-db6ac5e9808e911c643d4dada0e07ebd class=toggle>
<label for=section-db6ac5e9808e911c643d4dada0e07ebd class="flex justify-between"><a role=button>Kubernetes</a></label><ul><li><a href=/posts/k8s-informer/>k8s informer 介绍</a></li><li><a href=/posts/flannel/>深入了解 Kubernetes CNI 网络插件 Flannel</a></li><li><a href=/posts/kube-scheduler/>Kube Scheduler</a></li><li><a href=/posts/cri/>CRI 工作原理</a></li><li><a href=/posts/cni/>CNI 工作原理</a></li><li><a href=/posts/csi/>CSI 工作原理</a></li><li><a href=/posts/builing-multi-platform-container-images-guide/>构建多平台容器镜像</a></li><li><a href=/posts/rke2/>RKE2 安装 k8s 集群</a></li><li><a href=/posts/controller-runtime/>Controller Runtime</a></li><li><input type=checkbox id=section-8edd6114a0c1ce280c6628362e538ba7 class=toggle>
<label for=section-8edd6114a0c1ce280c6628362e538ba7 class="flex justify-between"><a role=button>问题记录</a></label><ul><li><a href=/posts/failed-to-reserve-sandbox-name/>failed to reserve sandbox name</a></li></ul></li></ul></li><li><input type=checkbox id=section-45ed28834a9c7fe37d3e4d15606fec65 class=toggle checked>
<label for=section-45ed28834a9c7fe37d3e4d15606fec65 class="flex justify-between"><a role=button>Database</a></label><ul><li><a href=/posts/sqlite3/ class=active>SQLite3</a></li></ul></li><li><span>Virtualization</span><ul><li><input type=checkbox id=section-7c5a43731ddd199a055dda51c8660688 class=toggle>
<label for=section-7c5a43731ddd199a055dda51c8660688 class="flex justify-between"><a role=button>KubeVirt</a></label><ul><li><a href=/posts/kubevirt-sidecar/>Kubevirt Hook Sidecar</a></li></ul></li><li><input type=checkbox id=section-01c36c077fb673b3c49c2a334c82e286 class=toggle>
<label for=section-01c36c077fb673b3c49c2a334c82e286 class="flex justify-between"><a role=button>libvirt</a></label><ul><li><a href=/posts/libvirt/>Libvirt 使用笔记</a></li><li><a href=/posts/create-vm-with-cloudinit/>创建虚拟机时使用 cloudinit 初始化</a></li></ul></li></ul></li><li><input type=checkbox id=section-51c4e989897e79573c9215830bc89f6c class=toggle>
<label for=section-51c4e989897e79573c9215830bc89f6c class="flex justify-between"><a role=button>Prometheus</a></label><ul><li><a href=/posts/prometheus-basics/>Prometheus 基础</a></li><li><a href=/posts/kube-prometheus-stack/>kube-prometheus-stack 安装</a></li><li><a href=/posts/node-exporter/>node-exporter 安装</a></li></ul></li><li><input type=checkbox id=section-3dd648d0479248759f2c07b8d5ee80be class=toggle>
<label for=section-3dd648d0479248759f2c07b8d5ee80be class="flex justify-between"><a role=button>Ceph</a></label><ul><li><a href=/posts/rook-ceph/>安装 Rook Ceph</a></li></ul></li><li><input type=checkbox id=section-ba2b1bb537fff210d58a51efd7bbb7f9 class=toggle>
<label for=section-ba2b1bb537fff210d58a51efd7bbb7f9 class="flex justify-between"><a role=button>LeetCode</a></label><ul><li><input type=checkbox id=section-3ef90a077ef0405107c088f6e344d4df class=toggle>
<label for=section-3ef90a077ef0405107c088f6e344d4df class="flex justify-between"><a role=button>链表</a></label><ul><li><a href=/posts/reverse-nodes-in-k-group/>25. K 个一组翻转链表</a></li></ul></li></ul></li><li><input type=checkbox id=section-bceaf15d0fd4d92497330a70b95e69d1 class=toggle>
<label for=section-bceaf15d0fd4d92497330a70b95e69d1 class="flex justify-between"><a role=button>其他</a></label><ul><li><a href=/posts/vscode-extensions/>Vscode Extensions</a></li><li><a href=/posts/macos-config/>MacOS Config</a></li><li><a href=/posts/vim-tricks/>Vim Tricks</a></li><li><a href=/posts/git-tricks/>Git Tricks</a></li></ul></li><li class=book-section-flat><span>&lt;&lt; 链接 >></span><ul><li><a href=/posts/about/>关于我</a></li><li><a href=/posts/links/>友链</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>SQLite3</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#rollback日志模式下的五种锁状态介绍>rollback日志模式下的五种锁状态介绍</a></li><li><a href=#优化篇>优化篇</a><ul><li><a href=#sqlite_busy-问题><code>SQLITE_BUSY</code> 问题</a></li><li><a href=#针对写操作慢的问题>针对写操作慢的问题</a></li></ul></li><li><a href=#参考文档>参考文档</a></li></ul></nav></aside></header><article class="markdown book-post"><h1>SQLite3</h1><div class="flex align-center text-small book-post-date"><img src=/svg/calendar.svg class=book-icon alt>
<span>2021-12-14</span></div><div class=book-post-content><h2 id=rollback日志模式下的五种锁状态介绍>rollback日志模式下的五种锁状态介绍
<a class=anchor href=#rollback%e6%97%a5%e5%bf%97%e6%a8%a1%e5%bc%8f%e4%b8%8b%e7%9a%84%e4%ba%94%e7%a7%8d%e9%94%81%e7%8a%b6%e6%80%81%e4%bb%8b%e7%bb%8d>#</a></h2><ul><li><code>UNLOCKED</code><ul><li>没锁状态</li></ul></li><li><code>SHARED</code><ul><li>获取<code>SHARED</code>锁才能执行读操作，一个数据库可同时存在多个<code>SHARED</code>锁</li></ul></li><li><code>RESERVED</code><ul><li>获取<code>RESERVED</code>锁才能在未来写数据库，一个数据库同一时间只能存在一个<code>RESERVED</code>锁</li><li>有<code>RESERVED</code>锁时说明还没开始写，所以有<code>RESERVED</code>锁时可以获取新的<code>SHARED</code>锁</li></ul></li><li><code>PENDING</code><ul><li>有<code>PENDING</code>锁意味着要开始写了，但是此时有其他连接拥有<code>SHARED</code>锁在读数据，此时写操作只能等待所有<code>SHARED</code>释放。</li><li><code>PENDING</code>阻塞其他连接获取新的<code>SHARED</code>锁，当<code>SHARED</code>锁释放完时转为<code>EXCLUSIVE</code>锁开始写操作。</li></ul></li><li><code>EXCLUSIVE</code><ul><li>同一时间只能存在一个<code>EXCLUSIVE</code>锁，并且有<code>EXCLUSIVE</code>锁存在时不允许其他任何锁类型存在。</li></ul></li></ul><p>所以总结一下就是读读可并发，读写不可并发，写写不可并发。</p><h2 id=优化篇>优化篇
<a class=anchor href=#%e4%bc%98%e5%8c%96%e7%af%87>#</a></h2><h3 id=sqlite_busy-问题><code>SQLITE_BUSY</code> 问题
<a class=anchor href=#sqlite_busy-%e9%97%ae%e9%a2%98>#</a></h3><p>看到上面这么多锁不能共存的情况应该会想到，冲突会很频繁，如 <code>EXCLUSIVE</code> 锁存在时不允许其他连接获取任何锁，当其他进程需要读写操作时就会获取锁失败，立即报 <code>SQLITE_BUSY</code> 错误。</p><p>设置 <code>busy_timeout</code> 就不会立即返回 <code>SQLITE_BUSY</code>，会定时retry失败的操作，如果在设置的 <code>busy_timeout</code> 时间内还没执行成功，依然会返回 <code>SQLITE_BUSY</code>。</p><p>使用不同sqlite驱动，设置 <code>busy_timeout</code> 的方式不同</p><ul><li>modernc.org/sqlite <code>database.db?_pragma=busy_timeout%3d50000</code></li><li>github.com/mattn/go-sqlite3 <code>database.db?_busy_timeout=50000</code></li></ul><p>Shared cache mode 支持 table level locks，暂时还没研究。</p><h3 id=针对写操作慢的问题>针对写操作慢的问题
<a class=anchor href=#%e9%92%88%e5%af%b9%e5%86%99%e6%93%8d%e4%bd%9c%e6%85%a2%e7%9a%84%e9%97%ae%e9%a2%98>#</a></h3><p>解决方案：将多个写操作放入一个事务里执行。sqlite官方<a href=https://www.sqlite.org/faq.html#q19>FAQ</a>对其解释如下</p><blockquote><p>(19) INSERT is really slow - I can only do few dozen INSERTs per second
Actually, SQLite will easily do 50,000 or more INSERT statements per second on an average desktop computer. But it will only do a few dozen transactions per second. Transaction speed is limited by the rotational speed of your disk drive. A transaction normally requires two complete rotations of the disk platter, which on a 7200RPM disk drive limits you to about 60 transactions per second.
Transaction speed is limited by disk drive speed because (by default) SQLite actually waits until the data really is safely stored on the disk surface before the transaction is complete. That way, if you suddenly lose power or if your OS crashes, your data is still safe. For details, read about <a href=https://www.sqlite.org/atomiccommit.html>atomic commit in SQLite..</a>
By default, each INSERT statement is its own transaction. But if you surround multiple INSERT statements with BEGIN&mldr;COMMIT then all the inserts are grouped into a single transaction. The time needed to commit the transaction is amortized over all the enclosed insert statements and so the time per insert statement is greatly reduced.
Another option is to run PRAGMA synchronous=OFF. This command will cause SQLite to not wait on data to reach the disk surface, which will make write operations appear to be much faster. But if you lose power in the middle of a transaction, your database file might go corrupt.</p></blockquote><p>测试环境</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 表信息</span>
</span></span><span style=display:flex><span>sqlite&gt; <span style=color:#66d9ef>select</span> count<span style=color:#f92672>(</span>*<span style=color:#f92672>)</span> from users;
</span></span><span style=display:flex><span><span style=color:#ae81ff>1553471</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 日志模式</span>
</span></span><span style=display:flex><span>sqlite&gt; PRAGMA journal_mode;
</span></span><span style=display:flex><span>delete
</span></span></code></pre></div><p>10次 insert 不在一个事务里</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ go test -bench<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;^Bench&#34;</span> -benchtime<span style=color:#f92672>=</span>5s .
</span></span><span style=display:flex><span>goos: linux
</span></span><span style=display:flex><span>goarch: amd64
</span></span><span style=display:flex><span>pkg: gocn/sqlite-test
</span></span><span style=display:flex><span>cpu: Intel<span style=color:#f92672>(</span>R<span style=color:#f92672>)</span> Xeon<span style=color:#f92672>(</span>R<span style=color:#f92672>)</span> Silver <span style=color:#ae81ff>4214</span> CPU @ 2.20GHz
</span></span><span style=display:flex><span>BenchmarkWrite-8              <span style=color:#ae81ff>52</span>         <span style=color:#ae81ff>128920972</span> ns/op
</span></span><span style=display:flex><span>BenchmarkRead-8           <span style=color:#ae81ff>141531</span>             <span style=color:#ae81ff>43400</span> ns/op
</span></span><span style=display:flex><span>BenchmarkWriteCGO-8           <span style=color:#ae81ff>63</span>          <span style=color:#ae81ff>81576398</span> ns/op
</span></span><span style=display:flex><span>BenchmarkReadCGO-8        <span style=color:#ae81ff>644850</span>              <span style=color:#ae81ff>8446</span> ns/op
</span></span><span style=display:flex><span>PASS
</span></span><span style=display:flex><span>ok      gocn/sqlite-test        29.049s
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 结果解释</span>
</span></span><span style=display:flex><span><span style=color:#75715e># write 和 read 单次执行内容分别是十条 inster 和一条 select</span>
</span></span><span style=display:flex><span><span style=color:#75715e># BenchmarkWrite 是使用 modernc.org/sqlite 驱动的写操作</span>
</span></span><span style=display:flex><span><span style=color:#75715e># BenchmarkWriteCGO 是使用 github.com/mattn/go-sqlite3 驱动的写操作</span>
</span></span></code></pre></div><p>10次 insert 在一个事务里后</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ go test -bench<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;^Bench&#34;</span> -benchtime<span style=color:#f92672>=</span>5s .
</span></span><span style=display:flex><span>goos: linux
</span></span><span style=display:flex><span>goarch: amd64
</span></span><span style=display:flex><span>pkg: gocn/sqlite-test
</span></span><span style=display:flex><span>cpu: Intel<span style=color:#f92672>(</span>R<span style=color:#f92672>)</span> Xeon<span style=color:#f92672>(</span>R<span style=color:#f92672>)</span> Silver <span style=color:#ae81ff>4214</span> CPU @ 2.20GHz
</span></span><span style=display:flex><span>BenchmarkWrite-8             <span style=color:#ae81ff>601</span>          <span style=color:#ae81ff>12099375</span> ns/op
</span></span><span style=display:flex><span>BenchmarkRead-8           <span style=color:#ae81ff>142848</span>             <span style=color:#ae81ff>43089</span> ns/op
</span></span><span style=display:flex><span>BenchmarkWriteCGO-8          <span style=color:#ae81ff>912</span>           <span style=color:#ae81ff>8050617</span> ns/op
</span></span><span style=display:flex><span>BenchmarkReadCGO-8        <span style=color:#ae81ff>720722</span>              <span style=color:#ae81ff>8244</span> ns/op
</span></span><span style=display:flex><span>PASS
</span></span><span style=display:flex><span>ok      gocn/sqlite-test        38.372s
</span></span></code></pre></div><p>可以看出来，写操作性能提升明显，写的单次操作(十次insert)时间直接下降了一个数量级，如果能将更多写操作放入一个事务里，性能提升也会越多，直至达到sqlite的写操作瓶颈(50,000 or more INSERT statements per second)。</p><h2 id=参考文档>参考文档
<a class=anchor href=#%e5%8f%82%e8%80%83%e6%96%87%e6%a1%a3>#</a></h2><ul><li><a href=https://www.sqlite.org/lockingv3.html>官方文档-五种锁状态介绍</a></li><li><a href=https://www.sqlite.org/faq.html#q19>官方FAQ</a></li><li><a href=https://activesphere.com/blog/2018/12/24/understanding-sqlite-busy#fn:1>Understanding SQLITE_BUSY</a></li><li><a href=https://github.com/mattn/go-sqlite3/blob/3392062c729d77820afc1f5cae3427f0de39e954/sqlite3.go#L919>github.com/mattn/go-sqlite3</a></li><li><a href=https://gitlab.com/cznic/sqlite/-/commit/e3be4b029c0e128faa7bfb5e06f67c8fda33db4a#bb99b1baec3b0c8f02dc4e87b04926bc377fd8db_803_802>modernc.org/sqlite</a></li></ul></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/go-bai/go-bai.github.io/commit/52e9a317e2ea3a0785571698961c607c1b640acd title='Last modified by go-bai | 2025-03-11' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>2025-03-11</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#rollback日志模式下的五种锁状态介绍>rollback日志模式下的五种锁状态介绍</a></li><li><a href=#优化篇>优化篇</a><ul><li><a href=#sqlite_busy-问题><code>SQLITE_BUSY</code> 问题</a></li><li><a href=#针对写操作慢的问题>针对写操作慢的问题</a></li></ul></li><li><a href=#参考文档>参考文档</a></li></ul></nav></div></aside></main></body></html>