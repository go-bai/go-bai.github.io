<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Controller Runtime | gobai's blog</title>
<link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css><link href=//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/xcode.min.css rel=stylesheet><style>h2::before,h3::before,h4::before,h5::before{color:#8f8f8f}h2::before{content:"## "}h3::before{content:"### "}h4::before{content:"#### "}h5::before{content:"##### "}</style></head><body><nav><ul class=menu><li><a href=/>Home</a></li><li><a href=/about/>About</a></li><li><a href=/tags/>Tags</a></li><li><a href=/index.xml>Subscribe</a></li></ul><hr></nav><div class=article-meta><h1><span class=title>Controller Runtime</span></h1><h4 class=date>2024/06/01</h4><p class=terms>Tags: <a href=/tags/informer>informer</a> <a href=/tags/controller>controller</a> <a href=/tags/workqueue>workqueue</a></p></div><nav id=TableOfContents><ul><li><a href=#介绍informer>介绍informer</a></li><li><a href=#开发crd时想到的一些问题>开发CRD时想到的一些问题</a><ul><li><a href=#更新local-store缓存和触发reconcile是否有先后顺序>更新local store缓存和触发reconcile是否有先后顺序</a></li><li><a href=#同一个crd-object会不会同时被reconcile>同一个crd object会不会同时被reconcile</a></li><li><a href=#如何解决进入reconcile之后读到的是旧数据的问题>如何解决进入reconcile之后读到的是旧数据的问题</a></li></ul></li></ul></nav><main><blockquote><p><a href=https://github.com/kubernetes-sigs/controller-runtime>controller-runtime</a>是在<a href=https://github.com/kubernetes/client-go/tree/master/tools/cache>client-go/tools/cache</a>和<a href=https://github.com/kubernetes/client-go/tree/master/util/workqueue>client-go/util/workqueue</a>的基础上实现的, 了解<code>client-go/tools/cache</code>和<code>client-go/util/workqueue</code>对理解<code>controller-runtime</code>很有帮助</p></blockquote><h2 id=介绍informer>介绍informer</h2><p>带着问题看</p><h2 id=开发crd时想到的一些问题>开发CRD时想到的一些问题</h2><h3 id=更新local-store缓存和触发reconcile是否有先后顺序>更新local store缓存和触发reconcile是否有先后顺序</h3><h3 id=同一个crd-object会不会同时被reconcile>同一个crd object会不会同时被reconcile</h3><p>这个全靠Queue数据结构设计的精妙, 保证了正在执行的reconcile不会处理相同的object</p><p>向queue中增加object之前会检查是否有次object存在于queue中，如果不存在则加入dirty set，如果也不存在于processing set才会加入queue中，当processing中的处理完成之后（调用Done），会将object从processing set种移除，如果次object在处理过程中加入到了dirty set，则将object再次加入到queue中
<a href=https://www.cnblogs.com/daniel-hutao/p/18010835/k8s_clientgo_workqueue>https://www.cnblogs.com/daniel-hutao/p/18010835/k8s_clientgo_workqueue</a></p><p>有几种队列，Queue，DelayingQueue，RateLimitingQueue</p><h3 id=如何解决进入reconcile之后读到的是旧数据的问题>如何解决进入reconcile之后读到的是旧数据的问题</h3><p>读到旧数据是否说明是先出发reconcile再更新local store的</p><p>My cache might be stale if I read from a cache! How should I deal with that?</p><p>在更新或patch status之后，通过wait.Pool(100ms, 2s, func()(bool, error))校验cache中的本object数据直至更新</p><p><a href=https://github.com/kubernetes-sigs/controller-runtime/blob/main/FAQ.md#q-my-cache-might-be-stale-if-i-read-from-a-cache-how-should-i-deal-with-that>https://github.com/kubernetes-sigs/controller-runtime/blob/main/FAQ.md#q-my-cache-might-be-stale-if-i-read-from-a-cache-how-should-i-deal-with-that</a></p><p><a href=https://github.com/kubernetes/test-infra/blob/8f0f19a905a20ed6f76386e5e11343d4bc2446a7/prow/plank/reconciler.go#L516-L520>https://github.com/kubernetes/test-infra/blob/8f0f19a905a20ed6f76386e5e11343d4bc2446a7/prow/plank/reconciler.go#L516-L520</a></p></main><footer><script defer src=https://cdn.jsdelivr.net/npm/@xiee/utils/js/center-img.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script>hljs.configure({languages:[]}),hljs.highlightAll()</script><hr>© <a href=https://blog.gocn.top>gobai</a> 2021 &ndash; 2024 | <a href=https://github.com/go-bai>Github</a></footer></body></html>