<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>SQLite3 Note | gobai's blog</title>
<link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css><link href=//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/xcode.min.css rel=stylesheet></head><body><nav><ul class=menu><li><a href=/>Home</a></li><li><a href=/about/>About</a></li><li><a href=/tags/>Tags</a></li><li><a href=/index.xml>Subscribe</a></li></ul><hr></nav><div class=article-meta><h1><span class=title>SQLite3 Note</span></h1><h4 class=date>2021/12/14</h4><p class=terms>Tags: <a href=/tags/sqlite3>sqlite3</a></p></div><main><h2 id=rollback日志模式下的五种锁状态介绍>rollback日志模式下的五种锁状态介绍</h2><ul><li><code>UNLOCKED</code><ul><li>没锁状态</li></ul></li><li><code>SHARED</code><ul><li>获取<code>SHARED</code>锁才能执行读操作，一个数据库可同时存在多个<code>SHARED</code>锁</li></ul></li><li><code>RESERVED</code><ul><li>获取<code>RESERVED</code>锁才能在未来写数据库，一个数据库同一时间只能存在一个<code>RESERVED</code>锁</li><li>有<code>RESERVED</code>锁时说明还没开始写，所以有<code>RESERVED</code>锁时可以获取新的<code>SHARED</code>锁</li></ul></li><li><code>PENDING</code><ul><li>有<code>PENDING</code>锁意味着要开始写了，但是此时有其他连接拥有<code>SHARED</code>锁在读数据，此时写操作只能等待所有<code>SHARED</code>释放。</li><li><code>PENDING</code>阻塞其他连接获取新的<code>SHARED</code>锁，当<code>SHARED</code>锁释放完时转为<code>EXCLUSIVE</code>锁开始写操作。</li></ul></li><li><code>EXCLUSIVE</code><ul><li>同一时间只能存在一个<code>EXCLUSIVE</code>锁，并且有<code>EXCLUSIVE</code>锁存在时不允许其他任何锁类型存在。</li></ul></li></ul><p>所以总结一下就是读读可并发，读写不可并发，写写不可并发。</p><h2 id=优化篇>优化篇</h2><h3 id=sqlite_busy-问题><code>SQLITE_BUSY</code> 问题</h3><p>看到上面这么多锁不能共存的情况应该会想到，冲突会很频繁，如 <code>EXCLUSIVE</code> 锁存在时不允许其他连接获取任何锁，当其他进程需要读写操作时就会获取锁失败，立即报 <code>SQLITE_BUSY</code> 错误。</p><p>设置 <code>busy_timeout</code> 就不会立即返回 <code>SQLITE_BUSY</code>，会定时retry失败的操作，如果在设置的 <code>busy_timeout</code> 时间内还没执行成功，依然会返回 <code>SQLITE_BUSY</code>。</p><p>使用不同sqlite驱动，设置 <code>busy_timeout</code> 的方式不同</p><ul><li>modernc.org/sqlite <code>database.db?_pragma=busy_timeout%3d50000</code></li><li>github.com/mattn/go-sqlite3 <code>database.db?_busy_timeout=50000</code></li></ul><p>Shared cache mode 支持 table level locks，暂时还没研究。</p><h3 id=针对写操作慢的问题>针对写操作慢的问题</h3><p>解决方案：将多个写操作放入一个事务里执行。sqlite官方<a href=https://www.sqlite.org/faq.html#q19>FAQ</a>对其解释如下</p><blockquote><p>(19) INSERT is really slow - I can only do few dozen INSERTs per second
Actually, SQLite will easily do 50,000 or more INSERT statements per second on an average desktop computer. But it will only do a few dozen transactions per second. Transaction speed is limited by the rotational speed of your disk drive. A transaction normally requires two complete rotations of the disk platter, which on a 7200RPM disk drive limits you to about 60 transactions per second.
Transaction speed is limited by disk drive speed because (by default) SQLite actually waits until the data really is safely stored on the disk surface before the transaction is complete. That way, if you suddenly lose power or if your OS crashes, your data is still safe. For details, read about <a href=https://www.sqlite.org/atomiccommit.html>atomic commit in SQLite..</a>
By default, each INSERT statement is its own transaction. But if you surround multiple INSERT statements with BEGIN&mldr;COMMIT then all the inserts are grouped into a single transaction. The time needed to commit the transaction is amortized over all the enclosed insert statements and so the time per insert statement is greatly reduced.
Another option is to run PRAGMA synchronous=OFF. This command will cause SQLite to not wait on data to reach the disk surface, which will make write operations appear to be much faster. But if you lose power in the middle of a transaction, your database file might go corrupt.</p></blockquote><p>测试环境</p><pre><code class=language-bash># 表信息
sqlite&gt; select count(*) from users;
1553471

# 日志模式
sqlite&gt; PRAGMA journal_mode;
delete
</code></pre><p>10次 insert 不在一个事务里</p><pre><code class=language-bash>$ go test -bench=&quot;^Bench&quot; -benchtime=5s .
goos: linux
goarch: amd64
pkg: gocn/sqlite-test
cpu: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz
BenchmarkWrite-8              52         128920972 ns/op
BenchmarkRead-8           141531             43400 ns/op
BenchmarkWriteCGO-8           63          81576398 ns/op
BenchmarkReadCGO-8        644850              8446 ns/op
PASS
ok      gocn/sqlite-test        29.049s

# 结果解释
# write 和 read 单次执行内容分别是十条 inster 和一条 select
# BenchmarkWrite 是使用 modernc.org/sqlite 驱动的写操作
# BenchmarkWriteCGO 是使用 github.com/mattn/go-sqlite3 驱动的写操作
</code></pre><p>10次 insert 在一个事务里后</p><pre><code class=language-bash>$ go test -bench=&quot;^Bench&quot; -benchtime=5s .
goos: linux
goarch: amd64
pkg: gocn/sqlite-test
cpu: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz
BenchmarkWrite-8             601          12099375 ns/op
BenchmarkRead-8           142848             43089 ns/op
BenchmarkWriteCGO-8          912           8050617 ns/op
BenchmarkReadCGO-8        720722              8244 ns/op
PASS
ok      gocn/sqlite-test        38.372s
</code></pre><p>可以看出来，写操作性能提升明显，写的单次操作(十次insert)时间直接下降了一个数量级，如果能将更多写操作放入一个事务里，性能提升也会越多，直至达到sqlite的写操作瓶颈(50,000 or more INSERT statements per second)。</p><p>参考文档</p><ul><li><a href=https://www.sqlite.org/lockingv3.html>官方文档-五种锁状态介绍</a></li><li><a href=https://www.sqlite.org/faq.html#q19>官方FAQ</a></li><li><a href=https://activesphere.com/blog/2018/12/24/understanding-sqlite-busy#fn:1>Understanding SQLITE_BUSY</a></li><li><a href=https://github.com/mattn/go-sqlite3/blob/3392062c729d77820afc1f5cae3427f0de39e954/sqlite3.go#L919>github.com/mattn/go-sqlite3</a></li><li><a href=https://gitlab.com/cznic/sqlite/-/commit/e3be4b029c0e128faa7bfb5e06f67c8fda33db4a#bb99b1baec3b0c8f02dc4e87b04926bc377fd8db_803_802>modernc.org/sqlite</a></li></ul></main><footer><script defer src=https://cdn.jsdelivr.net/npm/@xiee/utils/js/center-img.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script>hljs.configure({languages:[]}),hljs.highlightAll()</script><hr>© <a href=https://blog.gocn.top>gobai</a> 2021 &ndash; 2023 | <a href=https://github.com/go-bai>Github</a></footer></body></html>