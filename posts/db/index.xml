<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Database on gobai's blog</title><link>/posts/db/</link><description>Recent content in Database on gobai's blog</description><generator>Hugo</generator><language>en-us</language><atom:link href="/posts/db/index.xml" rel="self" type="application/rss+xml"/><item><title>Etcd</title><link>/posts/etcd/</link><pubDate>Sun, 25 Aug 2024 01:10:17 +0800</pubDate><guid>/posts/etcd/</guid><description/></item><item><title>Redis</title><link>/posts/redis/</link><pubDate>Sun, 25 Aug 2024 01:10:10 +0800</pubDate><guid>/posts/redis/</guid><description/></item><item><title>PostgreSQL</title><link>/posts/postgresql/</link><pubDate>Sun, 25 Aug 2024 01:10:04 +0800</pubDate><guid>/posts/postgresql/</guid><description/></item><item><title>MySQL</title><link>/posts/mysql/</link><pubDate>Sun, 25 Aug 2024 01:09:56 +0800</pubDate><guid>/posts/mysql/</guid><description/></item><item><title>MongoDB</title><link>/posts/mongodb/</link><pubDate>Sun, 25 Aug 2024 01:06:47 +0800</pubDate><guid>/posts/mongodb/</guid><description/></item><item><title>SQLite3</title><link>/posts/sqlite3/</link><pubDate>Tue, 14 Dec 2021 10:33:14 +0800</pubDate><guid>/posts/sqlite3/</guid><description>&lt;h2 id="rollback日志模式下的五种锁状态介绍">
 rollback日志模式下的五种锁状态介绍
 &lt;a class="anchor" href="#rollback%e6%97%a5%e5%bf%97%e6%a8%a1%e5%bc%8f%e4%b8%8b%e7%9a%84%e4%ba%94%e7%a7%8d%e9%94%81%e7%8a%b6%e6%80%81%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>&lt;code>UNLOCKED&lt;/code>
&lt;ul>
&lt;li>没锁状态&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>SHARED&lt;/code>
&lt;ul>
&lt;li>获取&lt;code>SHARED&lt;/code>锁才能执行读操作，一个数据库可同时存在多个&lt;code>SHARED&lt;/code>锁&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>RESERVED&lt;/code>
&lt;ul>
&lt;li>获取&lt;code>RESERVED&lt;/code>锁才能在未来写数据库，一个数据库同一时间只能存在一个&lt;code>RESERVED&lt;/code>锁&lt;/li>
&lt;li>有&lt;code>RESERVED&lt;/code>锁时说明还没开始写，所以有&lt;code>RESERVED&lt;/code>锁时可以获取新的&lt;code>SHARED&lt;/code>锁&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>PENDING&lt;/code>
&lt;ul>
&lt;li>有&lt;code>PENDING&lt;/code>锁意味着要开始写了，但是此时有其他连接拥有&lt;code>SHARED&lt;/code>锁在读数据，此时写操作只能等待所有&lt;code>SHARED&lt;/code>释放。&lt;/li>
&lt;li>&lt;code>PENDING&lt;/code>阻塞其他连接获取新的&lt;code>SHARED&lt;/code>锁，当&lt;code>SHARED&lt;/code>锁释放完时转为&lt;code>EXCLUSIVE&lt;/code>锁开始写操作。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>EXCLUSIVE&lt;/code>
&lt;ul>
&lt;li>同一时间只能存在一个&lt;code>EXCLUSIVE&lt;/code>锁，并且有&lt;code>EXCLUSIVE&lt;/code>锁存在时不允许其他任何锁类型存在。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>所以总结一下就是读读可并发，读写不可并发，写写不可并发。&lt;/p>
&lt;h2 id="优化篇">
 优化篇
 &lt;a class="anchor" href="#%e4%bc%98%e5%8c%96%e7%af%87">#&lt;/a>
&lt;/h2>
&lt;h3 id="sqlite_busy-问题">
 &lt;code>SQLITE_BUSY&lt;/code> 问题
 &lt;a class="anchor" href="#sqlite_busy-%e9%97%ae%e9%a2%98">#&lt;/a>
&lt;/h3>
&lt;p>看到上面这么多锁不能共存的情况应该会想到，冲突会很频繁，如 &lt;code>EXCLUSIVE&lt;/code> 锁存在时不允许其他连接获取任何锁，当其他进程需要读写操作时就会获取锁失败，立即报 &lt;code>SQLITE_BUSY&lt;/code> 错误。&lt;/p>
&lt;p>设置 &lt;code>busy_timeout&lt;/code> 就不会立即返回 &lt;code>SQLITE_BUSY&lt;/code>，会定时retry失败的操作，如果在设置的 &lt;code>busy_timeout&lt;/code> 时间内还没执行成功，依然会返回 &lt;code>SQLITE_BUSY&lt;/code>。&lt;/p>
&lt;p>使用不同sqlite驱动，设置 &lt;code>busy_timeout&lt;/code> 的方式不同&lt;/p>
&lt;ul>
&lt;li>modernc.org/sqlite &lt;code>database.db?_pragma=busy_timeout%3d50000&lt;/code>&lt;/li>
&lt;li>github.com/mattn/go-sqlite3 &lt;code>database.db?_busy_timeout=50000&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>Shared cache mode 支持 table level locks，暂时还没研究。&lt;/p>
&lt;h3 id="针对写操作慢的问题">
 针对写操作慢的问题
 &lt;a class="anchor" href="#%e9%92%88%e5%af%b9%e5%86%99%e6%93%8d%e4%bd%9c%e6%85%a2%e7%9a%84%e9%97%ae%e9%a2%98">#&lt;/a>
&lt;/h3>
&lt;p>解决方案：将多个写操作放入一个事务里执行。sqlite官方&lt;a href="https://www.sqlite.org/faq.html#q19">FAQ&lt;/a>对其解释如下&lt;/p>
&lt;blockquote>
&lt;p>(19) INSERT is really slow - I can only do few dozen INSERTs per second
Actually, SQLite will easily do 50,000 or more INSERT statements per second on an average desktop computer. But it will only do a few dozen transactions per second. Transaction speed is limited by the rotational speed of your disk drive. A transaction normally requires two complete rotations of the disk platter, which on a 7200RPM disk drive limits you to about 60 transactions per second.
Transaction speed is limited by disk drive speed because (by default) SQLite actually waits until the data really is safely stored on the disk surface before the transaction is complete. That way, if you suddenly lose power or if your OS crashes, your data is still safe. For details, read about &lt;a href="https://www.sqlite.org/atomiccommit.html">atomic commit in SQLite..&lt;/a>
By default, each INSERT statement is its own transaction. But if you surround multiple INSERT statements with BEGIN&amp;hellip;COMMIT then all the inserts are grouped into a single transaction. The time needed to commit the transaction is amortized over all the enclosed insert statements and so the time per insert statement is greatly reduced.
Another option is to run PRAGMA synchronous=OFF. This command will cause SQLite to not wait on data to reach the disk surface, which will make write operations appear to be much faster. But if you lose power in the middle of a transaction, your database file might go corrupt.&lt;/p></description></item></channel></rss>