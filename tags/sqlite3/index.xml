<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Sqlite3 on gobai's blog</title><link>/tags/sqlite3/</link><description>Recent content in Sqlite3 on gobai's blog</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Tue, 14 Dec 2021 10:33:14 +0800</lastBuildDate><atom:link href="/tags/sqlite3/index.xml" rel="self" type="application/rss+xml"/><item><title>SQLite3 Note</title><link>/posts/sqlite3-notes/</link><pubDate>Tue, 14 Dec 2021 10:33:14 +0800</pubDate><guid>/posts/sqlite3-notes/</guid><description>rollback日志模式下的五种锁状态介绍 UNLOCKED 没锁状态 SHARED 获取SHARED锁才能执行读操作，一个数据库可同时存在多个SHARED锁 RESERVED 获取RESERVED锁才能在未来写数据库，一个数据库同一时间只能存在一个RESERVED锁 有RESERVED锁时说明还没开始写，所以有RESERVED锁时可以获取新的SHARED锁 PENDING 有PENDING锁意味着要开始写了，但是此时有其他连接拥有SHARED锁在读数据，此时写操作只能等待所有SHARED释放。 PENDING阻塞其他连接获取新的SHARED锁，当SHARED锁释放完时转为EXCLUSIVE锁开始写操作。 EXCLUSIVE 同一时间只能存在一个EXCLUSIVE锁，并且有EXCLUSIVE锁存在时不允许其他任何锁类型存在。 所以总结一下就是读读可并发，读写不可并发，写写不可并发。
优化篇 SQLITE_BUSY 问题 看到上面这么多锁不能共存的情况应该会想到，冲突会很频繁，如 EXCLUSIVE 锁存在时不允许其他连接获取任何锁，当其他进程需要读写操作时就会获取锁失败，立即报 SQLITE_BUSY 错误。
设置 busy_timeout 就不会立即返回 SQLITE_BUSY，会定时retry失败的操作，如果在设置的 busy_timeout 时间内还没执行成功，依然会返回 SQLITE_BUSY。
使用不同sqlite驱动，设置 busy_timeout 的方式不同
modernc.org/sqlite database.db?_pragma=busy_timeout%3d50000 github.com/mattn/go-sqlite3 database.db?_busy_timeout=50000 Shared cache mode 支持 table level locks，暂时还没研究。
针对写操作慢的问题 解决方案：将多个写操作放入一个事务里执行。sqlite官方FAQ对其解释如下
(19) INSERT is really slow - I can only do few dozen INSERTs per second Actually, SQLite will easily do 50,000 or more INSERT statements per second on an average desktop computer.</description></item></channel></rss>