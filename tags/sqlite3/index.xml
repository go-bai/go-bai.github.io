<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Sqlite3 on gobai's blog</title><link>/tags/sqlite3/</link><description>Recent content in Sqlite3 on gobai's blog</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Tue, 14 Dec 2021 10:33:14 +0800</lastBuildDate><atom:link href="/tags/sqlite3/index.xml" rel="self" type="application/rss+xml"/><item><title>SQLite3</title><link>/posts/sqlite3/</link><pubDate>Tue, 14 Dec 2021 10:33:14 +0800</pubDate><guid>/posts/sqlite3/</guid><description>&lt;h2 id="rollback日志模式下的五种锁状态介绍">rollback日志模式下的五种锁状态介绍&lt;/h2>
&lt;ul>
&lt;li>&lt;code>UNLOCKED&lt;/code>
&lt;ul>
&lt;li>没锁状态&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>SHARED&lt;/code>
&lt;ul>
&lt;li>获取&lt;code>SHARED&lt;/code>锁才能执行读操作，一个数据库可同时存在多个&lt;code>SHARED&lt;/code>锁&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>RESERVED&lt;/code>
&lt;ul>
&lt;li>获取&lt;code>RESERVED&lt;/code>锁才能在未来写数据库，一个数据库同一时间只能存在一个&lt;code>RESERVED&lt;/code>锁&lt;/li>
&lt;li>有&lt;code>RESERVED&lt;/code>锁时说明还没开始写，所以有&lt;code>RESERVED&lt;/code>锁时可以获取新的&lt;code>SHARED&lt;/code>锁&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>PENDING&lt;/code>
&lt;ul>
&lt;li>有&lt;code>PENDING&lt;/code>锁意味着要开始写了，但是此时有其他连接拥有&lt;code>SHARED&lt;/code>锁在读数据，此时写操作只能等待所有&lt;code>SHARED&lt;/code>释放。&lt;/li>
&lt;li>&lt;code>PENDING&lt;/code>阻塞其他连接获取新的&lt;code>SHARED&lt;/code>锁，当&lt;code>SHARED&lt;/code>锁释放完时转为&lt;code>EXCLUSIVE&lt;/code>锁开始写操作。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>EXCLUSIVE&lt;/code>
&lt;ul>
&lt;li>同一时间只能存在一个&lt;code>EXCLUSIVE&lt;/code>锁，并且有&lt;code>EXCLUSIVE&lt;/code>锁存在时不允许其他任何锁类型存在。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>所以总结一下就是读读可并发，读写不可并发，写写不可并发。&lt;/p>
&lt;h2 id="优化篇">优化篇&lt;/h2>
&lt;h3 id="sqlite_busy-问题">&lt;code>SQLITE_BUSY&lt;/code> 问题&lt;/h3>
&lt;p>看到上面这么多锁不能共存的情况应该会想到，冲突会很频繁，如 &lt;code>EXCLUSIVE&lt;/code> 锁存在时不允许其他连接获取任何锁，当其他进程需要读写操作时就会获取锁失败，立即报 &lt;code>SQLITE_BUSY&lt;/code> 错误。&lt;/p>
&lt;p>设置 &lt;code>busy_timeout&lt;/code> 就不会立即返回 &lt;code>SQLITE_BUSY&lt;/code>，会定时retry失败的操作，如果在设置的 &lt;code>busy_timeout&lt;/code> 时间内还没执行成功，依然会返回 &lt;code>SQLITE_BUSY&lt;/code>。&lt;/p>
&lt;p>使用不同sqlite驱动，设置 &lt;code>busy_timeout&lt;/code> 的方式不同&lt;/p>
&lt;ul>
&lt;li>modernc.org/sqlite &lt;code>database.db?_pragma=busy_timeout%3d50000&lt;/code>&lt;/li>
&lt;li>github.com/mattn/go-sqlite3 &lt;code>database.db?_busy_timeout=50000&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>Shared cache mode 支持 table level locks，暂时还没研究。&lt;/p>
&lt;h3 id="针对写操作慢的问题">针对写操作慢的问题&lt;/h3>
&lt;p>解决方案：将多个写操作放入一个事务里执行。sqlite官方&lt;a href="https://www.sqlite.org/faq.html#q19">FAQ&lt;/a>对其解释如下&lt;/p></description></item></channel></rss>