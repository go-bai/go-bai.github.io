<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Docker on gobai's blog</title><link>/tags/docker/</link><description>Recent content in Docker on gobai's blog</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sun, 13 Oct 2024 11:27:56 +0800</lastBuildDate><atom:link href="/tags/docker/index.xml" rel="self" type="application/rss+xml"/><item><title>构建多平台容器镜像</title><link>/posts/builing-multi-platform-container-images-guide/</link><pubDate>Sun, 13 Oct 2024 11:27:56 +0800</pubDate><guid>/posts/builing-multi-platform-container-images-guide/</guid><description>&lt;blockquote>
&lt;p>构建多平台容器镜像&lt;/p>
&lt;/blockquote>
&lt;h2 id="docker-buildx-插件子命令">Docker buildx 插件/子命令&lt;/h2>
&lt;p>&lt;a href="https://github.com/docker/buildx">buildx&lt;/a> 是 Docker 的一个 CLI 插件，用于扩展来自于 &lt;a href="https://github.com/moby/buildkit">Moby BuildKit&lt;/a> 项目的构建功能。&lt;/p>
&lt;p>注意：buildx 需要 Docker 19.03 或更高版本。&lt;/p>
&lt;h2 id="buildkit">BuildKit&lt;/h2>
&lt;p>BuildKit是一个build引擎，它接收一个配置文件（Dockerfile），并转化成一个制品（容器镜像或其他制品）。相较与传统的build具有多阶段并发构建、更好的layer缓存支持等优点，Dockerfile中的RUN指令会被runc执行。&lt;/p>
&lt;p>Docker Engine 从 &lt;a href="https://docs.docker.com/engine/release-notes/23.0/#2300">23.0.0&lt;/a> 版本开始默认在Linux上使用Buildx和BuildKit为builder。&lt;/p>
&lt;h3 id="builder-a-buildkit-daemon">Builder: a BuildKit daemon&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://docs.docker.com/build/builders/">Builders介绍&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>一个 builder 是一个 BuildKit 守护进程，BuildKit是build引擎，它解决Dockerfile中的构建步骤，以生成容器镜像或其他制品。&lt;/p>
&lt;h3 id="build-drivers">Build drivers&lt;/h3>
&lt;p>Build 驱动有多种，例如 &lt;code>docker&lt;/code>、&lt;code>docker-container&lt;/code>、&lt;code>kubernetes&lt;/code>、&lt;code>remote&lt;/code> 等。&lt;/p>
&lt;ul>
&lt;li>&lt;code>docker&lt;/code> 使用捆绑在Docker守护进程中的BuildKit库。默认的Builder使用的该驱动。&lt;/li>
&lt;li>&lt;code>docker-container&lt;/code> 使用Docker创建一个专用的BuildKit容器。&lt;/li>
&lt;li>&lt;code>kubernetes&lt;/code> 在Kubernetes集群中创建BuildKit pods。&lt;/li>
&lt;li>&lt;code>remote&lt;/code> 直接连接到手动管理的BuildKit守护进程。&lt;/li>
&lt;/ul>
&lt;div style="text-align: center;">Build Drivers Comparison&lt;/div>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th style="text-align: left">Feature&lt;/th>
 &lt;th style="text-align: left">docker&lt;/th>
 &lt;th style="text-align: left">docker-container&lt;/th>
 &lt;th style="text-align: left">kubernetes&lt;/th>
 &lt;th style="text-align: left">remote&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td style="text-align: left">Automatically load image&lt;/td>
 &lt;td style="text-align: left">✅&lt;/td>
 &lt;td style="text-align: left">&lt;/td>
 &lt;td style="text-align: left">&lt;/td>
 &lt;td style="text-align: left">&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">Cache export&lt;/td>
 &lt;td style="text-align: left">✓*&lt;/td>
 &lt;td style="text-align: left">✅&lt;/td>
 &lt;td style="text-align: left">✅&lt;/td>
 &lt;td style="text-align: left">✅&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">Tarball output&lt;/td>
 &lt;td style="text-align: left">&lt;/td>
 &lt;td style="text-align: left">✅&lt;/td>
 &lt;td style="text-align: left">✅&lt;/td>
 &lt;td style="text-align: left">✅&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">Multi-arch images&lt;/td>
 &lt;td style="text-align: left">&lt;/td>
 &lt;td style="text-align: left">✅&lt;/td>
 &lt;td style="text-align: left">✅&lt;/td>
 &lt;td style="text-align: left">✅&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">BuildKit configuration&lt;/td>
 &lt;td style="text-align: left">&lt;/td>
 &lt;td style="text-align: left">✅&lt;/td>
 &lt;td style="text-align: left">&lt;/td>
 &lt;td style="text-align: left">Managed externally&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;div style="text-align: center;">* The docker driver doesn't support all cache export options&lt;/div>
&lt;h3 id="默认的-builder">默认的 Builder&lt;/h3>
&lt;p>docker engine 会自动创建一个默认的 builder 实例，例如 &lt;code>default&lt;/code>。默认的驱动是 &lt;code>docker&lt;/code>，不支持多平台构建。&lt;/p></description></item><item><title>解决Go应用在容器中的时区问题</title><link>/posts/solve-timezone-issue-in-go-application-in-container/</link><pubDate>Sat, 18 Feb 2023 16:12:01 +0800</pubDate><guid>/posts/solve-timezone-issue-in-go-application-in-container/</guid><description>&lt;h2 id="容器中的时区问题">容器中的时区问题&lt;/h2>
&lt;p>应用直接运行在服务器上需要设置服务器时区为东八区，现在很多应用都是部署在容器中了，同样也是要设置容器镜像的时区。&lt;/p>
&lt;p>许多容器镜像默认时区为 &lt;code>UTC&lt;/code> (&lt;a href="https://zh.wikipedia.org/zh-hans/%E5%8D%8F%E8%B0%83%E4%B8%96%E7%95%8C%E6%97%B6">Coordinated Universal Time 协调世界时&lt;/a>)，比东八区慢八个小时，当程序涉及数据库写入操作或者日志记录等功能时就会有时间差。&lt;/p>
&lt;p>常规解决方案一般两大类&lt;/p>
&lt;ol>
&lt;li>build docker镜像时就把镜像内的时区设置为 &lt;code>Asia/Shanghai&lt;/code>&lt;/li>
&lt;li>运行容器时把本地时区正常的主机的时区配置文件挂载到容器。&lt;/li>
&lt;/ol>
&lt;h3 id="看一下-go-是如何读取时区文件并设置-timetime-的时区的">看一下 &lt;code>Go&lt;/code> 是如何读取时区文件并设置 &lt;code>time.Time&lt;/code> 的时区的&lt;/h3>
&lt;p>&lt;code>Go&lt;/code> 源码 &lt;a href="https://github.com/golang/go/blob/master/src/time/zoneinfo_unix.go">src/time/zoneinfo_unix.go&lt;/a> 中代码和注释都很清晰👍&lt;/p>
&lt;pre>&lt;code class="language-golang">package time

import (
 &amp;quot;syscall&amp;quot;
)

// Many systems use /usr/share/zoneinfo, Solaris 2 has
// /usr/share/lib/zoneinfo, IRIX 6 has /usr/lib/locale/TZ,
// NixOS has /etc/zoneinfo.
var platformZoneSources = []string{
 &amp;quot;/usr/share/zoneinfo/&amp;quot;,
 &amp;quot;/usr/share/lib/zoneinfo/&amp;quot;,
 &amp;quot;/usr/lib/locale/TZ/&amp;quot;,
 &amp;quot;/etc/zoneinfo&amp;quot;,
}

func initLocal() {
 // consult $TZ to find the time zone to use.
 // no $TZ means use the system default /etc/localtime.
 // $TZ=&amp;quot;&amp;quot; means use UTC.
 // $TZ=&amp;quot;foo&amp;quot; or $TZ=&amp;quot;:foo&amp;quot; if foo is an absolute path, then the file pointed
 // by foo will be used to initialize timezone; otherwise, file
 // /usr/share/zoneinfo/foo will be used.

 tz, ok := syscall.Getenv(&amp;quot;TZ&amp;quot;)
 switch {
 case !ok:
 z, err := loadLocation(&amp;quot;localtime&amp;quot;, []string{&amp;quot;/etc&amp;quot;})
 if err == nil {
 localLoc = *z
 localLoc.name = &amp;quot;Local&amp;quot;
 return
 }
 case tz != &amp;quot;&amp;quot;:
 if tz[0] == ':' {
 tz = tz[1:]
 }
 if tz != &amp;quot;&amp;quot; &amp;amp;&amp;amp; tz[0] == '/' {
 if z, err := loadLocation(tz, []string{&amp;quot;&amp;quot;}); err == nil {
 localLoc = *z
 if tz == &amp;quot;/etc/localtime&amp;quot; {
 localLoc.name = &amp;quot;Local&amp;quot;
 } else {
 localLoc.name = tz
 }
 return
 }
 } else if tz != &amp;quot;&amp;quot; &amp;amp;&amp;amp; tz != &amp;quot;UTC&amp;quot; {
 if z, err := loadLocation(tz, platformZoneSources); err == nil {
 localLoc = *z
 return
 }
 }
 }

 // Fall back to UTC.
 localLoc.name = &amp;quot;UTC&amp;quot;
}
&lt;/code>&lt;/pre>
&lt;p>首先检查是否设置了 &lt;code>TZ&lt;/code> 环境变量&lt;/p></description></item></channel></rss>