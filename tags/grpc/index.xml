<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Grpc on gobai's blog</title><link>/tags/grpc/</link><description>Recent content in Grpc on gobai's blog</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sun, 12 May 2024 14:37:18 +0800</lastBuildDate><atom:link href="/tags/grpc/index.xml" rel="self" type="application/rss+xml"/><item><title>Kubevirt Hook Sidecar</title><link>/posts/kubevirt-sidecar/</link><pubDate>Sun, 12 May 2024 14:37:18 +0800</pubDate><guid>/posts/kubevirt-sidecar/</guid><description>&lt;h2 id="简介">简介&lt;/h2>
&lt;h3 id="背景">背景&lt;/h3>
&lt;blockquote>
&lt;p>在kubevirt中, 通过vmi的spec没办法涵盖所有的&lt;a href="https://libvirt.org/formatdomain.html">libvirt domain xml&lt;/a>元素, 所以有了hook sidecar功能来允许我们在define domain之前自定义domainSpecXML&lt;/p>
&lt;/blockquote>
&lt;h3 id="功能介绍">功能介绍&lt;/h3>
&lt;p>在kubevirt中, Hook Sidecar容器是sidecar container(和main application container跑在同一个pod中)用来在vm初始化完成前执行一些自定义操作.&lt;/p>
&lt;p>sidecar container与main container(compute)通过gRPC通讯, 有两种主要的sidecar hooks&lt;/p>
&lt;ol>
&lt;li>&lt;code>OnDefineDomain&lt;/code>: 这个hook帮助自定义libvirt的XML, 并通过gRPC协议返回最新的XML以创建vm&lt;/li>
&lt;li>&lt;code>PreCloudInitIso&lt;/code>: 这个hook帮助定义cloud-init配置, 它运行并返回最新的cloud-init data&lt;/li>
&lt;li>&lt;code>Shutdown&lt;/code>: 这个是&lt;code>v1alpha3&lt;/code>版本才支持的&lt;/li>
&lt;/ol>
&lt;p>使用hook sidecar功能需要在&lt;code>kv.spec.configuration.developerConfiguration.featureGates&lt;/code>中开启&lt;code>Sidecar&lt;/code>功能&lt;/p>
&lt;h2 id="源码分析">源码分析&lt;/h2>
&lt;h3 id="kubevirt-boot-sidecar-介绍">kubevirt-boot-sidecar 介绍&lt;/h3>
&lt;p>以下以&lt;a href="https://github.com/go-bai/kubevirt-boot-sidecar">kubevirt-boot-sidecar&lt;/a>为例讲述sidecar的工作流程, 这个sidecar支持修改&lt;code>引导设备顺序(boot)&lt;/code>和&lt;code>开启交互式引导菜单(bootmenu)&lt;/code>&lt;/p>
&lt;p>&lt;code>kubevirt-boot-sidecar&lt;/code>只实现了&lt;code>OnDefineDomain&lt;/code>, 下面也是主要串一下OnDefineDomain相关的&lt;/p>
&lt;h3 id="sidecar工作流程">sidecar工作流程&lt;/h3>
&lt;ol>
&lt;li>&lt;code>virt-launcher&lt;/code>刚启动时收集所有sidecar信息
&lt;pre>&lt;code class="language-golang">// cmd/virt-launcher/virt-launcher.go
func main() {
 hookSidecars := pflag.Uint(&amp;quot;hook-sidecars&amp;quot;, 0, &amp;quot;Number of requested hook sidecars, virt-launcher will wait for all of them to become available&amp;quot;)
 // 收集所有sidecar的信息
 err := hookManager.Collect(*hookSidecars, *qemuTimeout)

 // 启动 cmd server, 这里面有 SyncVirtualMachine 方法, 具体的实现在 func (l *LibvirtDomainManager) SyncVMI
 // virt-handler在初始化完虚拟机硬盘等之后会通过 SyncVirtualMachine 调用SyncVMI函数开始创建domain
 // SyncVMI将vmi spec转换为domainSpec, 然后调用hooksManager.OnDefineDomain执行所有的sidecar的OnDefineDomain方法
 // 最终用OnDefineDomain编辑后的domainSpec创建domain
 cmdServerDone := startCmdServer(cmdclient.UninitializedSocketOnGuest(), domainManager, stopChan, options)
}

// pkg/hooks/manager.go
// numberOfRequestedHookSidecars为vmi注解 hooks.kubevirt.io/hookSidecars 的数组长度, 在virt-controller生成pod manifest的逻辑中计算得出
func (m *hookManager) Collect(numberOfRequestedHookSidecars uint, timeout time.Duration) error {
 // callbacksPerHookPoint
 callbacksPerHookPoint, err := m.collectSideCarSockets(numberOfRequestedHookSidecars, timeout)
 m.CallbacksPerHookPoint = callbacksPerHookPoint
}

// pkg/hooks/manager.go
func (m *hookManager) collectSideCarSockets(numberOfRequestedHookSidecars uint, timeout time.Duration) (map[string][]*callBackClient, error) {
 callbacksPerHookPoint := make(map[string][]*callBackClient)
 processedSockets := make(map[string]bool)
 timeoutCh := time.After(timeout)

 for uint(len(processedSockets)) &amp;lt; numberOfRequestedHookSidecars {
 sockets, err := os.ReadDir(m.hookSocketSharedDirectory)
 // 遍历 /var/run/kubevirt-hooks/ 目录下的 unix socket 文件
 for _, socket := range sockets {
 select {
 case &amp;lt;-timeoutCh:
 return nil, fmt.Errorf(&amp;quot;Failed to collect all expected sidecar hook sockets within given timeout&amp;quot;)
 default:
 if _, processed := processedSockets[socket.Name()]; processed {
 continue
 }

 // 连接 sock 文件对应的 sidecar server 的 Info 函数获取 server 实现了哪些 hook(onDefineDomain或preCloudInitIso)
 callBackClient, notReady, err := processSideCarSocket(filepath.Join(m.hookSocketSharedDirectory, socket.Name()))
 if notReady {
 log.Log.Info(&amp;quot;Sidecar server might not be ready yet, retrying in the next iteration&amp;quot;)
 continue
 } else if err != nil {
 return nil, err
 }

 // callbacksPerHookPoint[onDefineDomain|preCloudInitIso][]*callBackClient{}
 // 聚合出 onDefineDomain:[&amp;quot;aaaa.sock&amp;quot;,&amp;quot;bbbb.sock&amp;quot;]
 for _, subscribedHookPoint := range callBackClient.subscribedHookPoints {
 callbacksPerHookPoint[subscribedHookPoint.GetName()] = append(callbacksPerHookPoint[subscribedHookPoint.GetName()], callBackClient)
 }

 processedSockets[socket.Name()] = true
 }
 }
 time.Sleep(time.Second)
 }
 // {&amp;quot;onDefineDomain&amp;quot;:[{&amp;quot;SocketPath&amp;quot;:&amp;quot;/var/run/kubevirt-hooks/shim-xxxx.sock&amp;quot;, &amp;quot;Version&amp;quot;:&amp;quot;v1alpha3&amp;quot;, &amp;quot;subscribedHookPoints&amp;quot;: [{&amp;quot;name&amp;quot;: &amp;quot;onDefineDomain&amp;quot;, &amp;quot;priority&amp;quot;: 0}]}]}
 return callbacksPerHookPoint, nil
}
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>&lt;code>virt-launcher&lt;/code>启动之后, &lt;code>virt-handler&lt;/code>会执行一些本地盘等相关初始化配置后通过gRPC调用&lt;code>virt-launcher&lt;/code>的&lt;code>SyncVirtualMachine&lt;/code>方法开始创建domain
&lt;ol>
&lt;li>&lt;code>SyncVMI&lt;/code>
&lt;ol>
&lt;li>&lt;code>Convert_v1_VirtualMachineInstance_To_api_Domain&lt;/code> 将 vmi 转换为 domainSpec&lt;/li>
&lt;li>&lt;code>lookupOrCreateVirDomain&lt;/code> 先&lt;code>LookupDomainByName&lt;/code>, 如果已存在则直接退出
&lt;ol>
&lt;li>&lt;code>preStartHook&lt;/code>
&lt;pre>&lt;code class="language-golang">hooksManager := hooks.GetManager()
// 执行所有的 PreCloudInitIso sidecar
cloudInitData, err = hooksManager.PreCloudInitIso(vmi, cloudInitData)
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>&lt;code>setDomainSpecWithHooks&lt;/code>
&lt;pre>&lt;code class="language-golang">// pkg/virt-launcher/virtwarp/util/libvirt-helper.go
func SetDomainSpecStrWithHooks(virConn cli.Connection, vmi *v1.VirtualMachineInstance, wantedSpec *api.DomainSpec) (cli.VirDomain, error) {
 hooksManager := getHookManager()
 // 执行所有的 OnDefineDomain sidecar
 domainSpec, err := hooksManager.OnDefineDomain(wantedSpec, vmi)
 // 调用 virConn.DomainDefineXML 创建 domain
 return SetDomainSpecStr(virConn, vmi, domainSpec)
}

// /pkg/hooks/manager.go
func (m *hookManager) OnDefineDomain(domainSpec *virtwrapApi.DomainSpec, vmi *v1.VirtualMachineInstance) (string, error) {
 domainSpecXML, err := xml.MarshalIndent(domainSpec, &amp;quot;&amp;quot;, &amp;quot;\t&amp;quot;)

 callbacks, found := m.CallbacksPerHookPoint[hooksInfo.OnDefineDomainHookPointName]
 if !found {
 return string(domainSpecXML), nil
 }

 vmiJSON, err := json.Marshal(vmi)

 for _, callback := range callbacks {
 // 执行所有的sidecar OnDefineDomain函数, 一次次编辑domainSpecXML
 domainSpecXML, err = m.onDefineDomainCallback(callback, domainSpecXML, vmiJSON)
 }

 return string(domainSpecXML), nil
}

// /pkg/hooks/manager.go
func (m *hookManager) onDefineDomainCallback(callback *callBackClient, domainSpecXML, vmiJSON []byte) ([]byte, error) {
 // dial /var/run/kubevirt-hooks/shim-xxxx.sock
 conn, err := grpcutil.DialSocketWithTimeout(callback.SocketPath, 1)

 switch callback.Version {
 case hooksV1alpha3.Version:
 client := hooksV1alpha3.NewCallbacksClient(conn)
 // 调用sidecar server 的 OnDefineDomain 方法
 result, err := client.OnDefineDomain(ctx, &amp;amp;hooksV1alpha3.OnDefineDomainParams{
 DomainXML: domainSpecXML,
 Vmi: vmiJSON,
 })
 domainSpecXML = result.GetDomainXML()
 }

 return domainSpecXML, nil
}
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>会发现上面主要是sidecar client视角, 没有介绍sidecar server在哪实现的, 最新的解决方案是搭配&lt;code>sidecar-shim&lt;/code>, 下面开始介绍&lt;/p></description></item></channel></rss>