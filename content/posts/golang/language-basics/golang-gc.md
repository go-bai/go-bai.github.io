---
title: "GC 垃圾回收"
date: 2025-03-05T13:10:46+08:00
# bookComments: false
# bookSearchExclude: false
---

## GC 垃圾回收

分配在栈上的数据，随着函数调用栈的销毁便释放了自身占用的内存，可以被程序重复利用。

协程栈也是从堆上分配的，也在 mheap 管理的 span 中，mspan.spanState 会记录该 span 是用作堆内存还是栈内存。

而分配在堆上的数据，他们占用的内存需要程序主动释放才可以重新使用，否则称为垃圾。

### 三色标记原理

三色标记法，白色，灰色和黑色

1. 垃圾回收开始会把所有数据（栈、堆、数据段）都标记为白色
2. 然后把直接追踪(扫描全局数据区和栈区)到的 root 节点标记为灰色，灰色代表基于当前节点展开的追踪还未完成。
3. 基于某个节点的追踪任务完成后标记为黑色，标识有用并且无需基于它再追踪。
4. 没有灰色节点后意味着标记工作结束。此时有用的数据为黑色，垃圾都是白色，在清除阶段回收这些白色的垃圾即可。

### 混合写屏障

通过 `混合写屏障` 防止GC过程中并发修改对象的问题。

- `混合写屏障` 继承了插入写屏障的优点，起始时无需 STW 打快照，直接并发扫描垃圾即可
- `混合写屏障` 继承了删除写屏障的优点，赋值器是黑色赋值器，GC期间，任何在栈上创建的新对象，均为黑色。扫描过后就不需要扫描了，这样就消除了插入写屏障最后 STW 的重新扫描栈了。
- `混合写屏障` 扫描栈虽然不用 STW，但是扫描某一个具体的栈的时候，还是要停止这个 goroutine 赋值器的工作（针对一个 goroutine 来说，是暂停扫的，要么全灰，要么全黑，是原子状态切换的）

### GC 触发时机

1. 主动触发：调用 `runtime.GC`
2. 被动触发：使用系统监控 `sysmon`，该触发条件由 `runtime.forcegcperiod` 控制，默认为 2 分钟。当超过时间没有产生任何 GC 时，强制触发 GC。使用步调算法。。。

### GC 流程

GC 划分为五个阶段
