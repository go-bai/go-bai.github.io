<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>gobai's blog</title><link>/</link><description>Recent content on gobai's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 14 Dec 2021 10:33:14 +0800</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>sqlite3 笔记</title><link>/post/sqlite3-notes/</link><pubDate>Tue, 14 Dec 2021 10:33:14 +0800</pubDate><guid>/post/sqlite3-notes/</guid><description>rollback日志模式下的五种锁状态介绍 UNLOCKED 没锁状态 SHARED 获取SHARED锁才能执行读操作，一个数据库可同时存在多个SHARED锁 RESERVED 获取RESERVED锁才能在未来写数据库，一个数据库同一时间只能存在一个RESERVED锁 有RESERVED锁时说明还没开始写，所以有RESERVED锁时可以获取新的SHARED锁 PENDING 有PENDING锁意味着要开始写了，但是此时有其他连接拥有SHARED锁在读数据，此时写操作只能等待所有SHARED释放。 PENDING阻塞其他连接获取新的SHARED锁，当SHARED锁释放完时转为EXCLUSIVE锁开始写操作。 EXCLUSIVE 同一时间只能存在一个EXCLUSIVE锁，并且有EXCLUSIVE锁存在时不允许其他任何锁类型存在。 所以总结一下就是读读可并发，读写不可并发，写写不可并发。
优化篇 SQLITE_BUSY 问题 看到上面这么多锁不能共存的情况应该会想到，冲突会很频繁，如 EXCLUSIVE 锁存在时不允许其他连接获取任何锁，当其他进程需要读写操作时就会获取锁失败，立即报 SQLITE_BUSY 错误。
设置 busy_timeout 就不会立即返回 SQLITE_BUSY，会定时retry失败的操作，如果在设置的 busy_timeout 时间内还没执行成功，依然会返回 SQLITE_BUSY。
使用不同sqlite驱动，设置 busy_timeout 的方式不同
modernc.org/sqlite database.db?_pragma=busy_timeout%3d50000 github.com/mattn/go-sqlite3 database.db?_busy_timeout=50000 Shared cache mode 支持 table level locks，暂时还没研究。
针对写操作慢的问题 解决方案：将多个写操作放入一个事务里执行。sqlite官方FAQ对其解释如下
(19) INSERT is really slow - I can only do few dozen INSERTs per second Actually, SQLite will easily do 50,000 or more INSERT statements per second on an average desktop computer.</description></item><item><title>Vim Tricks</title><link>/post/vim-tricks/</link><pubDate>Wed, 24 Nov 2021 21:45:54 +0800</pubDate><guid>/post/vim-tricks/</guid><description>批量替换 批量替换 1.1.1.1 为 2.2.2.2
:%s+1.1.1.1+2.2.2.2 两行合为一行 NORMAL 模式下按 shift + j 就会将光标下一行合并到当前行行尾</description></item><item><title>减小go程序编译后的体积</title><link>/post/go-app-reduce-size/</link><pubDate>Mon, 22 Nov 2021 10:29:02 +0800</pubDate><guid>/post/go-app-reduce-size/</guid><description>编译经典程序 程序代码 package main import &amp;quot;fmt&amp;quot; func main() { fmt.Println(&amp;quot;Hello World.&amp;quot;) } 编译环境 $ go version go version go1.16.7 linux/amd64 0. 直接编译 $ go build -o helloword main.go $ ls -lh helloword -rwxrwxr-x 1 gobai gobai 1.9M Nov 23 09:34 helloword 1. 修改编译选项 除去编译时带的符号表和调试信息
$ go build -ldflags=&amp;quot;-s -w&amp;quot; -o helloword main.go $ ls -lh helloword -rwxrwxr-x 1 gobai gobai 1.3M Nov 23 09:38 helloword 2. 使用 UPX 对直接编译出的二进制使用 upx 进一步压缩</description></item><item><title>Linux Tricks</title><link>/post/linux-tricks/</link><pubDate>Sun, 14 Nov 2021 01:47:04 +0800</pubDate><guid>/post/linux-tricks/</guid><description>journal 相关 查看 journal 占用磁盘量 journalctl --disk-usage 查看某 service 日志 journalctl -f -u xxx.service 限制持久化配置 vim /etc/systemd/journald.conf SystemMaxUse=16M ForwardToSyslog=no 参考链接
https://www.cnsre.cn/posts/210401140104/</description></item><item><title>Git Tricks</title><link>/post/git-tricks/</link><pubDate>Fri, 12 Nov 2021 15:36:19 +0800</pubDate><guid>/post/git-tricks/</guid><description>目前对git的理解程度较低，只是能应付日常开发，所以写出来的水平有限。
暂存当前代码改动 场景是在一个git branch写了不少代码以后发现写错分支了，总不能删了再重新写吧，可以使用 git stash 命令解决。
// 将当前改动的代码暂存 git stash // git checkout 到你要工作的分支 git checkout your_workspace_branch // 把暂存的代码从堆栈弹出到当前分支 git stash pop</description></item><item><title>区间重叠问题</title><link>/post/interval-overlap-problem/</link><pubDate>Wed, 10 Nov 2021 11:59:41 +0800</pubDate><guid>/post/interval-overlap-problem/</guid><description>问题描述 给定一个左闭右开连续区间 [L,R), 判断与另一个左闭右开连续区间是否有重合部分。
问题分析 首先对于两个连续区间有重合部分的状态有四种，没重合部分的状态有两种，不重合两种状态如下所示。
可以看出，只需要满足有一个区间的右边界小于等于另一个区间的左边界即可。 即满足 a.R &amp;lt;= b.L || b.R &amp;lt;= a.L 即可保证两个左闭右开区间不重合。(左闭右闭同理，去掉等于号即可)</description></item><item><title>关于我</title><link>/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/about/</guid><description> 服务端开发工程师，职场新人 喜欢一些“不务正业”的技术
目前在学的内容
kubernetes openstack postgresql</description></item></channel></rss>