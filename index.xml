<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Home on gobai's blog</title><link>/</link><description>Recent content in Home on gobai's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 06 Jan 2024 17:38:38 +0800</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>OpenWrt</title><link>/posts/openwrt/</link><pubDate>Sat, 06 Jan 2024 17:38:38 +0800</pubDate><guid>/posts/openwrt/</guid><description>很久没折腾OpenWrt了, 囊中羞涩, 没有其他合适的设备, 这次是在KVM虚机中运行使用(ALL IN BOOM!)
先亮个当前的穷人版家庭网络拓扑图
准备qcow2镜像 首先下载最新的镜像, 截止目前最新版为23.05.2, 我这里下载的是x86-64的镜像
wget https://downloads.openwrt.org/releases/23.05.2/targets/x86/64/openwrt-23.05.2-x86-64-generic-ext4-combined.img.gz # 解压 gunzip openwrt-23.05.2-x86-64-generic-ext4-combined.img.gz # 这里因为我要作为KVM虚拟机的镜像, 所以转换为qcow2格式. 如果是在物理机上部署, 可以直接直接刷到U盘上. qemu-img convert -f raw openwrt-23.05.2-x86-64-generic-ext4-combined.img -O qcow2 openwrt.qcow2 # 默认virtual size只有120 MiB, 担心不够用所以增加到1GiB qemu-img resize openwrt.qcow2 +904M 运行虚机 我这里将镜像复制到了/var/lib/libvirt/disks/目录下
cp openwrt.qcow2 /var/lib/libvirt/disks/ 使用virt-install运行,
# 运行, 这里网络指定的之前文章中创建的网桥网络br0 virt-install --name openwrt --memory 256 --vcpus 1 --network bridge=br0,model=e1000 --disk path=/var/lib/libvirt/disks/openwrt.qcow2,bus=ide --import --autostart --osinfo detect=on,require=off --graphics vnc,listen=0.0.0.0 --noautoconsole 配置网络 连接console配置网络
virsh console openwrt 修改网络配置文件 /etc/config/network 只修改了lan配置, 其他都是默认的 具体修改了lan配置的ipaddr, 增加gateway和dns</description></item><item><title>dhclient</title><link>/posts/dhclient/</link><pubDate>Mon, 09 Oct 2023 21:37:55 +0800</pubDate><guid>/posts/dhclient/</guid><description>在机器上使用netplan+NetworkManager配置bridged network之后
最近经常电脑用着用着就不能联网了，发现enp1s0总是偶尔冒出一个ipv4地址，并且路由表会多出一个从enp1s0出去的default路由。后来看journalctl日志发现是dhclient搞的事情(学艺不精, 没第一时间联系起来)。
下面是部分日志：
➜ ~ journalctl -n 1000000 | grep '192.168.1.22\|enp1s0' ... 10月 09 20:14:25 gobai-SER dhclient[107299]: DHCPREQUEST for 192.168.1.22 on enp1s0 to 255.255.255.255 port 67 (xid=0x4745a8ce) 10月 09 20:14:26 gobai-SER dhclient[73666]: DHCPREQUEST for 192.168.1.22 on enp1s0 to 255.255.255.255 port 67 (xid=0x2cfc74b3) 10月 09 20:14:26 gobai-SER dhclient[157839]: DHCPREQUEST for 192.168.1.22 on enp1s0 to 255.255.255.255 port 67 (xid=0x453b8549) 10月 09 20:14:28 gobai-SER dhclient[170251]: DHCPREQUEST for 192.168.1.22 on enp1s0 to 255.</description></item><item><title>Creating a bridged network with netplan on Ubuntu 22.04</title><link>/posts/creating-a-bridged-network-with-netplan-on-ubuntu-22-04/</link><pubDate>Wed, 04 Oct 2023 13:01:59 +0800</pubDate><guid>/posts/creating-a-bridged-network-with-netplan-on-ubuntu-22-04/</guid><description>本地LAN环境
LAN网关 192.168.1.1 子网掩码 255.255.255.0 DHCP范围 192.168.1.2-192.168.32 创建一个bridged network 创建一个网桥br0给虚机使用，使得虚机和其他设备都在一个LAN下
总配置(netplan get)如下:
network: version: 2 renderer: NetworkManager ethernets: enp1s0: dhcp4: false dhcp6: false bridges: br0: addresses: - &amp;quot;192.168.1.100/24&amp;quot; nameservers: addresses: - 192.168.1.1 dhcp4: false dhcp6: false interfaces: - enp1s0 parameters: stp: false routes: - to: &amp;quot;default&amp;quot; via: &amp;quot;192.168.1.1&amp;quot; 由三个文件组成:
/etc/netplan/01-network-manager-all.yaml # Let NetworkManager manage all devices on this system network: version: 2 renderer: NetworkManager /etc/netplan/10-ethernet-enp1s0.yaml network: ethernets: enp1s0: dhcp4: false dhcp6: false /etc/netplan/99-bridged-network-br0.</description></item><item><title>删除分区并扩容另一个分区和根文件系统</title><link>/posts/delete-partition-and-expand-another/</link><pubDate>Mon, 02 Oct 2023 16:54:05 +0800</pubDate><guid>/posts/delete-partition-and-expand-another/</guid><description>现在要将 /dev/sda3 分区删掉并扩容到 /dev/sda2, 并且在不重启服务器的情况下扩容根文件系统(跟文件系统 / 挂载在 /dev/sda2 上, 并且 filesystem 是 ext4)
磁盘初始分区和挂载情况 ➜ ~ lsblk /dev/sda NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8:0 0 100G 0 disk ├─sda1 8:1 0 512M 0 part /boot/efi ├─sda2 8:2 0 98.5G 0 part / └─sda3 8:3 0 976M 0 part ➜ ~ fdisk -l /dev/sda Disk /dev/sda: 100 GiB, 107374182400 bytes, 209715200 sectors Disk model: BlockVolume Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 1048576 bytes Disklabel type: gpt Disk identifier: 40BED670-8B91-4520-9785-DB1F1035C039 Device Start End Sectors Size Type /dev/sda1 2048 1050623 1048576 512M EFI System /dev/sda2 1050624 207714303 206663680 98.</description></item><item><title>Vscode Extensions</title><link>/posts/vscode-extensions/</link><pubDate>Mon, 25 Sep 2023 21:27:06 +0800</pubDate><guid>/posts/vscode-extensions/</guid><description>记录我的vscode使用的扩展插件 持续补充中
vscode-icons-mac GitLens Go Remote - SSH shellman REST Client Todo Tree 一些配置 &amp;quot;workbench.tree.indent&amp;quot;: 16</description></item><item><title>Ubuntu Config</title><link>/posts/ubuntu-config/</link><pubDate>Sun, 24 Sep 2023 10:56:12 +0800</pubDate><guid>/posts/ubuntu-config/</guid><description>配置中文输入法 Open Settings, go to Region &amp;amp; Language -&amp;gt; Manage Installed Languages -&amp;gt; Install / Remove languages. Select Chinese (Simplified). Make sure Keyboard Input method system has Ibus selected. Apply. Reboot Log back in, reopen Settings, go to Keyboard. Click on the &amp;ldquo;+&amp;rdquo; sign under Input sources. Select Chinese (China) and then Chinese (Intelligent Pinyin). ubuntu-22-04-chinese-simplified-pinyin-input-support
安装 oh my zsh sudo apt install zsh curl -y sh -c &amp;quot;$(curl -fsSL https://raw.</description></item><item><title>Virt Manager</title><link>/posts/virt-manager/</link><pubDate>Sat, 23 Sep 2023 22:28:35 +0800</pubDate><guid>/posts/virt-manager/</guid><description>环境 操作系统 Ubuntu 22.04.3 LTS Desktop ➜ ~ cat /etc/os-release PRETTY_NAME=&amp;quot;Ubuntu 22.04.3 LTS&amp;quot; NAME=&amp;quot;Ubuntu&amp;quot; VERSION_ID=&amp;quot;22.04&amp;quot; VERSION=&amp;quot;22.04.3 LTS (Jammy Jellyfish)&amp;quot; VERSION_CODENAME=jammy ID=ubuntu ID_LIKE=debian HOME_URL=&amp;quot;https://www.ubuntu.com/&amp;quot; SUPPORT_URL=&amp;quot;https://help.ubuntu.com/&amp;quot; BUG_REPORT_URL=&amp;quot;https://bugs.launchpad.net/ubuntu/&amp;quot; PRIVACY_POLICY_URL=&amp;quot;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&amp;quot; UBUNTU_CODENAME=jammy 网络环境 已创建bridged network, Creating a bridged network with netplan on Ubuntu 22.04
安装配置 安装 sudo apt install virt-manager qemu bridge-utils -y 配置 bridge 类型网络 TODO
修改libvirtd配置文件并重启 sudo vim /etc/libvirt/qemu.conf
- #user = &amp;quot;root&amp;quot; + user = &amp;quot;gobai&amp;quot; - #group = &amp;quot;root&amp;quot; + group = &amp;quot;gobai&amp;quot; sudo systemctl restart libvirtd</description></item><item><title>Linux I/O Redirection</title><link>/posts/io-redirection/</link><pubDate>Sat, 23 Sep 2023 09:06:09 +0800</pubDate><guid>/posts/io-redirection/</guid><description/></item><item><title>Linux jq Command</title><link>/posts/jq-command/</link><pubDate>Sat, 09 Sep 2023 15:04:05 +0800</pubDate><guid>/posts/jq-command/</guid><description>jq命令对于api boy还是挺常用的，在此记录一下一些常用的操作。</description></item><item><title>解决Go应用在容器中的时区问题</title><link>/posts/solve-timezone-issue-in-go-application-in-container/</link><pubDate>Sat, 18 Feb 2023 16:12:01 +0800</pubDate><guid>/posts/solve-timezone-issue-in-go-application-in-container/</guid><description>容器中的时区问题 应用直接运行在服务器上需要设置服务器时区为东八区，现在很多应用都是部署在容器中了，同样也是要设置容器镜像的时区。
许多容器镜像默认时区为 UTC (Coordinated Universal Time 协调世界时)，比东八区慢八个小时，当程序涉及数据库写入操作或者日志记录等功能时就会有时间差。
常规解决方案一般两大类
build docker镜像时就把镜像内的时区设置为 Asia/Shanghai 运行容器时把本地时区正常的主机的时区配置文件挂载到容器。 看一下 Go 是如何读取时区文件并设置 time.Time 的时区的 Go 源码 src/time/zoneinfo_unix.go 中代码和注释都很清晰👍
package time import ( &amp;quot;syscall&amp;quot; ) // Many systems use /usr/share/zoneinfo, Solaris 2 has // /usr/share/lib/zoneinfo, IRIX 6 has /usr/lib/locale/TZ, // NixOS has /etc/zoneinfo. var platformZoneSources = []string{ &amp;quot;/usr/share/zoneinfo/&amp;quot;, &amp;quot;/usr/share/lib/zoneinfo/&amp;quot;, &amp;quot;/usr/lib/locale/TZ/&amp;quot;, &amp;quot;/etc/zoneinfo&amp;quot;, } func initLocal() { // consult $TZ to find the time zone to use. // no $TZ means use the system default /etc/localtime.</description></item><item><title>SQLite3 Note</title><link>/posts/sqlite3-notes/</link><pubDate>Tue, 14 Dec 2021 10:33:14 +0800</pubDate><guid>/posts/sqlite3-notes/</guid><description>rollback日志模式下的五种锁状态介绍 UNLOCKED 没锁状态 SHARED 获取SHARED锁才能执行读操作，一个数据库可同时存在多个SHARED锁 RESERVED 获取RESERVED锁才能在未来写数据库，一个数据库同一时间只能存在一个RESERVED锁 有RESERVED锁时说明还没开始写，所以有RESERVED锁时可以获取新的SHARED锁 PENDING 有PENDING锁意味着要开始写了，但是此时有其他连接拥有SHARED锁在读数据，此时写操作只能等待所有SHARED释放。 PENDING阻塞其他连接获取新的SHARED锁，当SHARED锁释放完时转为EXCLUSIVE锁开始写操作。 EXCLUSIVE 同一时间只能存在一个EXCLUSIVE锁，并且有EXCLUSIVE锁存在时不允许其他任何锁类型存在。 所以总结一下就是读读可并发，读写不可并发，写写不可并发。
优化篇 SQLITE_BUSY 问题 看到上面这么多锁不能共存的情况应该会想到，冲突会很频繁，如 EXCLUSIVE 锁存在时不允许其他连接获取任何锁，当其他进程需要读写操作时就会获取锁失败，立即报 SQLITE_BUSY 错误。
设置 busy_timeout 就不会立即返回 SQLITE_BUSY，会定时retry失败的操作，如果在设置的 busy_timeout 时间内还没执行成功，依然会返回 SQLITE_BUSY。
使用不同sqlite驱动，设置 busy_timeout 的方式不同
modernc.org/sqlite database.db?_pragma=busy_timeout%3d50000 github.com/mattn/go-sqlite3 database.db?_busy_timeout=50000 Shared cache mode 支持 table level locks，暂时还没研究。
针对写操作慢的问题 解决方案：将多个写操作放入一个事务里执行。sqlite官方FAQ对其解释如下
(19) INSERT is really slow - I can only do few dozen INSERTs per second Actually, SQLite will easily do 50,000 or more INSERT statements per second on an average desktop computer.</description></item><item><title>Vim Tricks</title><link>/posts/vim-tricks/</link><pubDate>Wed, 24 Nov 2021 21:45:54 +0800</pubDate><guid>/posts/vim-tricks/</guid><description>批量替换 批量替换 v1.6.1 为 v2.7.0
:%s/v1.6.1/v2.7.0/g 两行合为一行 NORMAL 模式下按 shift + j 就会将光标下一行合并到当前行行尾</description></item><item><title>减小go程序编译后的体积</title><link>/posts/go-app-reduce-size/</link><pubDate>Mon, 22 Nov 2021 10:29:02 +0800</pubDate><guid>/posts/go-app-reduce-size/</guid><description>编译经典程序 程序代码 package main import &amp;quot;fmt&amp;quot; func main() { fmt.Println(&amp;quot;Hello World.&amp;quot;) } 编译环境 $ go version go version go1.16.7 linux/amd64 0. 直接编译 $ go build -o helloword main.go $ ls -lh helloword -rwxrwxr-x 1 gobai gobai 1.9M Nov 23 09:34 helloword 1. 修改编译选项 除去编译时带的符号表和调试信息
$ go build -ldflags=&amp;quot;-s -w&amp;quot; -o helloword main.go $ ls -lh helloword -rwxrwxr-x 1 gobai gobai 1.3M Nov 23 09:38 helloword 2. 使用 UPX 对直接编译出的二进制使用 upx 进一步压缩</description></item><item><title>About Systemd</title><link>/posts/systemd-journal/</link><pubDate>Sun, 14 Nov 2021 01:47:04 +0800</pubDate><guid>/posts/systemd-journal/</guid><description>记录一下查看和操作 systemd 日志的几个常用命令
1 常用过滤日志日志的命令 1.1 根据时间约束过滤日志 1.1.1 获取 2023-01-15 00:00:00 之后的日志 journalctl --since '2023-01-15 00:00:00' 1.1.2 获取 2023-01-15 00:00:00 之后, 2023-01-15 12:00:00 之前的日志 journalctl --since '2023-01-15 00:00:00' --until '2023-01-15 12:00:00' 1.2 只查看一个服务(Unit)的日志 journalctl -u nginx 1.3 自由组合约束条件 journalctl -u nginx --since '2023-01-15 00:00:00' --until '2023-01-15 12:00:00' 2 查看日志占用磁盘量 journalctl --disk-usage Output Archived and active journals take up 3.9G in the file system. 3 删除旧的日志 3.1 只保留最近 一个月 的日志 journalctl --vacuum-time=1month 3.</description></item><item><title>Git Tricks</title><link>/posts/git-tricks/</link><pubDate>Fri, 12 Nov 2021 15:36:19 +0800</pubDate><guid>/posts/git-tricks/</guid><description>目前对git的理解程度较低，只是能应付日常开发，所以写出来的水平有限。
暂存当前代码改动 场景是在一个git branch写了不少代码以后发现写错分支了，总不能删了再重新写吧，可以使用 git stash 命令解决。
// 将当前改动的代码暂存 git stash // git checkout 到你要工作的分支 git checkout your_workspace_branch // 把暂存的代码从堆栈弹出到当前分支 git stash pop</description></item><item><title>关于我</title><link>/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/about/</guid><description> 服务端开发工程师，职场新人 喜欢一些“不务正业”的技术
目前在学的内容 golang kubernetes kubevirt ceph openstack terraform postgresql sqlite linux 我的设备 Macbook Pro 2018 15 inch 16+256 零刻 SER5 Pro AMD Ryzen7-5700U Ubuntu 22.04 + QEMU/KVM 5G CPE VN009 OnePlus 9R 联系方式: WeChat: Z28tYmFp</description></item></channel></rss>